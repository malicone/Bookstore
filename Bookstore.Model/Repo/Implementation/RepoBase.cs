using Bookstore.Model.Repo.Interface;
using System;
using System.Collections.Generic;
using System.Data.Common;
using System.Text;
using FirebirdSql.Data.FirebirdClient;
using Dapper.Contrib.Extensions;
using Dapper;
using Bookstore.Model.Utils;
using System.Data;
using System.Threading.Tasks;
using System.Collections.ObjectModel;
using FirebirdSql.Data.Isql;

namespace Bookstore.Model.Repo.Implementation
{
    /// <summary>
    /// Implements basic input/output operations with db. Uses Dapper and Dapper.Contrib libraries.
    /// </summary>
    /// <typeparam name="T">Model class. Every model is table in the db.</typeparam>
    public class RepoBase<T> : IRepoBase<T> where T : EntityBase, new()
    {
        public IDbConnection Connection { get; private set; }

        public RepoBase( FbConnection connection )
        {
            Connection = connection;
        }

        /// <summary>
        /// Inserts entity into db (Connection property).
        /// </summary>
        /// <param name="entity">Entity to be inserted.</param>
        /// <param name="transaction">Started transaction the method to be run in. You can ignore it if no transactions are used.</param>
        /// <returns>Id of new inserted entity. Important! If id/key is not autogenerated the method generates it.
        /// If id/key is not 0 (integer default) it is ignored and inserted in the db.</returns>
        public virtual long Add( T entity, IDbTransaction transaction = null )
        {
            if ( OpenConnection() )
            {
                // There are no autoincreament (triggers + generators) in the tables (legacy code) so we need to generate them
                int id = entity.GetEntityId();
                if ( id == default( int ) )
                {
                    id = (int)GenerateNewId( transaction );
                    entity.SetEntityId( id );
                }

                // Connection.Insert( entity ) throws System.IndexOutOfRangeException: 'Index was outside the bounds of the array.'
                // There is error in Dapper.Contrib.SqlMapperExtensions.cs in FbAdapter.Insert method (explicit keys are ignored)
                // So have to use list insert
                List<T> list = new List<T>( 1 );
                list.Add( entity );
                Connection.Insert( list, transaction );
                return id;
            }
            return 0;
        }

        /// <summary>
        /// Inserts list of entities into the db. 
        /// Important! It's better to run this method within transaction to avoid primary key violation.
        /// </summary>
        /// <param name="entities">Entities to be inserted.</param>
        /// <param name="transaction">Started transaction the method to be run in. You can ignore it if no transactions are used.</param>
        /// <returns>Number of inserted entities.</returns>
        public virtual long AddRange( IEnumerable<T> entities, IDbTransaction transaction = null )
        {
            if ( OpenConnection() )
            {
                // There are no autoincreament (triggers + generators) in the tables (legacy code) so we need to generate them
                long newId = GenerateNewId( transaction );
                foreach ( var entity in entities )
                {
                    int id = entity.GetEntityId();
                    if ( id == default( int ) )
                    {
                        entity.SetEntityId( (int)newId );
                        newId++;
                    }
                }
                return Connection.Insert( entities, transaction );
            }
            return 0;
        }

        public virtual long Count( IDbTransaction transaction = null )
        {
            if ( OpenConnection() )
            {
                var entity = new T();
                string tableName = entity.GetTableName();
                return Connection.ExecuteScalar<long>( $"SELECT COUNT(*) FROM {tableName}", null, transaction );
            }
            return 0;
        }

        public virtual bool Delete( long id, IDbTransaction transaction = null )
        {
            if ( OpenConnection() )
            {
                T entityToDelete = Connection.Get<T>( id, transaction );
                if ( entityToDelete == null )
                    return false;
                return Connection.Delete( entityToDelete, transaction );
            }
            return false;
        }

        public virtual bool DeleteAll( IDbTransaction transaction = null )
        {
            if ( OpenConnection() )
            {
                return Connection.DeleteAll<T>( transaction );
            }
            return false;
        }

        public virtual void ExecuteQuery( string sql, object param = null, IDbTransaction transaction = null )
        {
            if ( OpenConnection() )
            {                                
                FbScript script = new FbScript( sql );
                script.Parse();
                foreach ( var item in script.Results )
                {
                    Connection.Execute( item.Text, param, transaction );
                }                

                // Dosn't work - A transaction is currently active. Parallel transactions are not supported.
                //FbScript script = new FbScript( sql );
                //script.Parse();
                //FbBatchExecution batch = new FbBatchExecution( (FbConnection)Connection );
                //batch.AppendSqlStatements( script );
                //batch.Execute();
            }
        }

        /// <summary>
        /// Searches entity in the db by id.
        /// </summary>
        /// <param name="id">Id to search by.</param>
        /// <param name="transaction">Started transaction the method to be run in. You can ignore it if no transactions are used.</param>
        /// <returns>Found entity or null if nothing found.</returns>
        public virtual T Get( long id, IDbTransaction transaction = null )
        {
            if ( OpenConnection() )
            {
                return Connection.Get<T>( id, transaction );
            }
            return null;
        }
        /// <summary>
        /// Searches default entity to use for initilization.
        /// </summary>
        /// <param name="transaction">Started transaction the method to be run in. You can ignore it if no transactions are used.</param>
        /// <returns>Base implementation returns entity with min id or null if table is empty or some problem (connection closed etc).</returns>
        public virtual T GetDefaultEntity( IDbTransaction transaction = null )
        {
            if ( OpenConnection() )
            {
                long? minId = GetMinId( transaction );
                if ( minId.HasValue )
                {
                    return Get( minId.Value, transaction );
                }
            }
            return null;
        }

        public virtual IEnumerable<T> GetAll( IDbTransaction transaction = null )
        {
            if ( OpenConnection() )
            {
                var foundEntities = Connection.GetAll<T>( transaction );
                return foundEntities ?? GetEmptyEnumerable();
            }
            return GetEmptyEnumerable();
        }
        public virtual async Task<IEnumerable<T>> GetAllAsync( IDbTransaction transaction = null )
        {
            if ( OpenConnection() )
            {
                var foundEntities = await Connection.GetAllAsync<T>( transaction );
                return foundEntities ?? GetEmptyEnumerable();
            }
            return GetEmptyEnumerable();
        }

        public virtual IEnumerable<T> GetAllOrderBy( string columnName = null, IDbTransaction transaction = null )
        {
            if ( OpenConnection() )
            {
                string sql = ComposeOrderByQuery( columnName );
                var foundEntities = Connection.Query<T>( sql, null, transaction );
                return foundEntities ?? GetEmptyEnumerable();
            }
            return GetEmptyEnumerable();
        }
        public virtual async Task<IEnumerable<T>> GetAllOrderByAsync( string columnName = null, IDbTransaction transaction = null )
        {
            if ( OpenConnection() )
            {
                string sql = ComposeOrderByQuery( columnName );
                var foundEntities = await Connection.QueryAsync<T>( sql, null, transaction );
                return foundEntities ?? GetEmptyEnumerable();
            }
            return GetEmptyEnumerable();
        }
        private string ComposeOrderByQuery( string sortColumnName = null )
        {
            var entity = new T();
            string tableName = entity.GetTableName();
            string actualSortColumnName = sortColumnName ?? entity.GetDefaultSortColumnName();
            string orderClause = entity.IsColumnTypeOfString( actualSortColumnName ) ? $"UPPER({actualSortColumnName})" : $"{actualSortColumnName}";
            return $"SELECT * FROM {tableName} ORDER BY {orderClause}";
        }

        public virtual IEnumerable<T> GetPage( int first = 10, int skip = 0, IDbTransaction transaction = null )
        {
            if ( OpenConnection() )
            {
                var entity = new T();
                string tableName = entity.GetTableName();
                var foundEntities = Connection.Query<T>( $"SELECT FIRST {first} SKIP {skip} * FROM {tableName}", null, transaction );
                return foundEntities ?? GetEmptyEnumerable();
            }
            return GetEmptyEnumerable();
        }
        public virtual IEnumerable<string> GetEntitiesLike( string fieldName, string searchText, bool groupBy, IDbTransaction transaction = null )
        {
            if ( OpenConnection() )
            {
                var entity = new T();
                string tableName = entity.GetTableName();
                string groupByClause = groupBy ? $"group by {fieldName}" : string.Empty;                
                string sql = $@"select trim({fieldName}) from {tableName} where upper(trim({fieldName})) 
like '{searchText.ToUpper()}%' {groupByClause} order by {fieldName}";
                var foundEntities = Connection.Query<string>( sql, null, transaction );
                return foundEntities ?? GetEmptyEnumerable<string>();
            }
            return GetEmptyEnumerable<string>();
        }
        public virtual long? GetMaxId( IDbTransaction transaction = null )
        {
            if ( OpenConnection() )
            {
                var entity = new T();
                string tableName = entity.GetTableName();
                string keyName = entity.GetKeyName();
                return Connection.ExecuteScalar<long?>( $"SELECT MAX({keyName}) FROM {tableName}", null, transaction );
            }
            return null;
        }
        public virtual long? GetMinId( IDbTransaction transaction = null )
        {
            if ( OpenConnection() )
            {
                var entity = new T();
                string tableName = entity.GetTableName();
                string keyName = entity.GetKeyName();
                return Connection.ExecuteScalar<long?>( $"SELECT MIN({keyName}) FROM {tableName}", null, transaction );
            }
            return null;
        }
        public virtual bool Update( T entity, IDbTransaction transaction = null )
        {
            if ( OpenConnection() )
            {
                return Connection.Update( entity, transaction );
            }
            return false;
        }
        public virtual bool Exists( long id, IDbTransaction transaction = null )
        {
            if ( OpenConnection() )
            {
                return Connection.Get<T>( id, transaction ) != null;
            }
            return false;
        }
        #region Hidden
        protected virtual bool OpenConnection()
        {
            bool needReopen = ( Connection.State == ConnectionState.Closed ) || ( Connection.State == ConnectionState.Broken );
            if ( needReopen )
            {
                try
                {
                    Connection.Open();
                    return true;
                }
                catch
                {
                    return false;
                }
            }
            return true;
        }

        protected virtual long GenerateNewId( IDbTransaction transaction = null )
        {
            long? maxId = GetMaxId( transaction );
            return maxId == null ? 1 : maxId.Value + 1;
        }

        protected virtual IEnumerable<T> GetEmptyEnumerable()
        {
            return new Collection<T>();
        }
        protected virtual IEnumerable<S> GetEmptyEnumerable<S>()
        {
            return new Collection<S>();
        }
        protected virtual DateTime GenerateCreatedTimestamp()
        {
            return DateTime.Today;
        }
        #endregion
    }
}